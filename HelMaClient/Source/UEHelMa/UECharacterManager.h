// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "GameInfo.h"
#include <map>
#include <set>
#include <list>
#include <GEMath.h>


//캐릭터들의 충돌체를 모두 관리할 예정 
/**
 * 
 */
class UEHELMA_API UECharacterManager
{
public:
	static UECharacterManager Inst;

public:
	static UECharacterManager& GetInst()
	{
		return Inst;
	}

private:
	ACharacter* MainCharacter;
	UWorld* MainWorld;
	float4 m_Size;
	FString OtherName;

public:
	int Count;

public:
	ACharacter* GetMainCharacter()
	{
		return MainCharacter;
	}

	void SetOtherName(const FString& _Name) 
	{
		OtherName = _Name;
	}

	FString GetOtherName()
	{
		return OtherName;
	}

public:
	void CharacterManagerInit(ACharacter* _MainCharacter, UWorld* _World);


	// 액터 관리용 함수.
public:
	std::list<ACharacter*> m_Destroy;

	void ActorRelease();
	void Clear();
	void DestoryRelease();

	std::map<int, TMap<__int64, ACharacter*>> m_AllGameWaitActor;
	template<typename T>
	T* FindIDWaitActor(int _Order, __int64 _ID)
	{
		ACharacter** FindPtr = m_AllGameWaitActor[_Order].Find(_ID);
		if (nullptr != FindPtr)
		{
			return Cast<T>(FindPtr[0]);
		}

		return nullptr;
	}

	template<typename T>
	T* CreateServerManagerWaitObject(TSubclassOf<T> _CreateType, FVector _Pos, int _Order, __int64 _ID,FString _Name)
	{

		if (nullptr != m_AllGameWaitActor[_Order].Find(_ID))
		{
			return nullptr;
		}

		FActorSpawnParameters	tParams;
		tParams.SpawnCollisionHandlingOverride =
			ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;

		SetOtherName(_Name);
		//ASummonPotal* Summon = GetWorld()->SpawnActor<ASummonPotal>(
		//	SummonClass, vPos, GetActorRotation(), tParams);
		T* NewActor = MainWorld->SpawnActor<T>(_CreateType, _Pos, { 0,0,0 }, tParams);
		if (_ID == -1)
		{
			_ID = reinterpret_cast<__int64>(NewActor);
		}

		// -1이면 클라이언트에서만 관리되는 모드고 자신의 주소가 들어갔을거라는 이야기니까.
		NewActor->SetUpdateID(_ID);

		m_AllGameWaitActor[_Order].Add(_ID, NewActor);

		return NewActor;
	}

	// Player Destroy되는게 아니고 자리를 옮기는것 뿐이라.
	void EraseServerManagerWaitObject(int _Order, __int64 _ID)
	{
		ACharacter** Actor = m_AllGameWaitActor[_Order].Find(_ID);
		if (nullptr == Actor)
		{
			return;
		}


		m_AllGameWaitActor[_Order].Remove(_ID);
	}

	// 충돌체 만들면서 넣어주는것.
	template<typename T>
	T* WaitActorInActorCol(int _Order, __int64 _ID/*, float4 _Scale*//*, COLTYPE _Type*/)
	{
		T* FindActor = FindIDWaitActor<T>(_Order, _ID);
		if (nullptr != FindActor)
		{
			UE_LOG(LogTemp, Error, TEXT("WaitActorInActorCol(%lld)"), _ID);
			EraseServerManagerWaitObject(_Order, _ID);
			m_AllGameActor[_Order].Add(_ID, FindActor);
			//GameCol* GetPtr = InsertCollison(std::make_shared<GameCol>(_Type, _Order, FindActor), _Scale);
			//FindActor->SetGameCol(GetPtr);
		}
		return FindActor;
	}



public:


	//       order                UpdateId 오브젝트
	std::map<int, TMap<__int64, ACharacter*>> m_AllGameActor;

	template<typename T>
	T* FindIDActor(int _Order, __int64 _ID)
	{
		ACharacter** FindPtr = m_AllGameActor[_Order].Find(_ID);
		if (nullptr != FindPtr)
		{
			return Cast<T>(FindPtr[0]);
		}
		return nullptr;
	}

	template<typename T>
	T* CreateServerManagerObject(TSubclassOf<T> _CreateType, FVector _Pos, int _Order, __int64 _ID,FString _Name)
	{
		if (nullptr != m_AllGameActor[_Order].Find(_ID))
		{
			UE_LOG(LogTemp, Error, TEXT("if (nullptr != m_AllGameActor[_Order].Find(_ID)), %d, %d"), _Order, _ID);
			return nullptr;
		}

		FActorSpawnParameters	tParams;
		tParams.SpawnCollisionHandlingOverride =
			ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;

		SetOtherName(_Name);

		T* NewActor = MainWorld->SpawnActor<T>(_CreateType, _Pos, { 0,0,0 },tParams);

		if (nullptr == NewActor)
		{
			UE_LOG(LogTemp, Error, TEXT("nullptr == NewActor %d, %d"), _Order, _ID);
		}

		if (_ID == -1)
		{
			_ID = reinterpret_cast<__int64>(NewActor);
		}

		// -1이면 클라이언트에서만 관리되는 모드고 자신의 주소가 들어갔을거라는 이야기니까.
		NewActor->SetUpdateID(_ID);

		m_AllGameActor[_Order].Add(_ID, NewActor);

		return NewActor;
	}

	template<typename T>
	T* CreateServerManagerObjectToCol(TSubclassOf<T> _CreateType, FVector _Pos, int _Order, __int64 _ID,FString _Name/*, COLTYPE _Type*/)
	{
		T* NewActor = CreateServerManagerObject(_CreateType, _Pos, _Order, _ID, _Name);
		if (nullptr != NewActor)
		{
		/*	GameCol* GetPtr = InsertCollison(std::make_shared<GameCol>(_Type, _Order, NewActor), _Scale);
			NewActor->SetGameCol(GetPtr);*/
		}
		return NewActor;
	}

	void EraseServerManagerObject(int _Order, __int64 _ID)
	{
		// 여러개를 찾아오는 방식이네요.
		ACharacter** Actor = m_AllGameActor[_Order].Find(_ID);
		if (nullptr == Actor)
		{
			UE_LOG(LogTemp, Error, TEXT("Server Erase Fail if (nullptr == Actor) %d %lld"), _Order, _ID);
			return;
		}

		//// 충돌체도 같이 날려줘야 합니다.
		//std::map<AActor*, std::shared_ptr<GameCol>>::iterator FindIter = m_ColMap[_Order].find(Actor[0]);
		//if (m_ColMap[_Order].end() != FindIter)
		//{
		//	FindIter->second->Death();
		//}


		UE_LOG(LogTemp, Error, TEXT("Server Erase OK %d %lld"), _Order, _ID);
		m_AllGameActor[_Order].Remove(_ID);
	}

public:
	UECharacterManager();
	~UECharacterManager();
};
